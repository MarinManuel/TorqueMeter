import argparse
import datetime
import itertools
import logging
import re
import warnings
from pathlib import Path

import numpy as np
import pandas as pd
import scipy.stats as st
import seaborn as sns
from PySide6.QtCore import QDate, Qt
from PySide6.QtGui import QShortcut, QKeySequence
from PySide6.QtWidgets import (
    QMainWindow,
    QApplication,
    QFileDialog,
)
from matplotlib.backend_bases import MouseEvent
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg
from matplotlib.figure import Figure
from matplotlib.gridspec import GridSpec

from ui_mainwindow_ui import Ui_MainWindow

TORQUE_FILES_EXTENSIONS = [".xlsx", ".csv"]
TORQUE_DATA_FILENAME_RE = re.compile(
    r"^(?P<ID>[^_]+)_P(?P<Age>\d+)_(?P<Limb>[HF])(?P<Side>[RL])_(?P<Speed>[^_]+)"
    r"(?:_(?P<Comments>.+))?\.(?P<Extension>.+)$"
)
TORQUE_ARM_LENGTH = 7  # cm
TORQUE_CYCLE_COLORS = [(0.8, 0.8, 0.8), (1.0, 1.0, 1.0)]
TORQUE_CYCLE_EXCLUDED = "#FFAABB"
RESULT_FIELDS = {
    "ID": str,
    "ExpDate": "datetime64[ns]",
    "Age": int,
    "Limb": str,
    "Side": str,
    "Speed": float,
    "Comments": str,
    "Filename": str,
    "Filtered": int,
    "Cycles": str,
    "Rejected": bool,
    "Validated": bool,
    "Slope": float,
    "R": float,
}
DEFAULT_OUTLIER_THRESHOLD = 3.0

###
# Logging module
###
logger = logging.getLogger("TorqueAnalyzer")
handler = logging.StreamHandler()
# noinspection SpellCheckingInspection
formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
handler.setFormatter(formatter)
logger.addHandler(handler)
LOGGING_LEVELS = [logging.NOTSET, logging.WARNING, logging.INFO, logging.DEBUG]


def get_angle_cycles(angle_data, threshold=None):
    """
    returns the points where the angles cross the threshold
    :param angle_data: the angle timeseries.
    :param threshold: the angle to use to detect cycles. If None, then use the first angle value in the timeseries
    :return:
    """
    threshold = angle_data[0] if threshold is None else threshold
    idx = np.argwhere(np.diff(angle_data > threshold)).flatten().tolist()
    idx = idx[::2] + [len(angle_data) - 1]
    idx = list(itertools.pairwise(idx))
    return idx


def grouper(iterable, n, *, incomplete="fill", fill_value=None):
    from itertools import zip_longest

    "Collect data into non-overlapping fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, fill_value='x') --> ABC DEF Gxx
    # grouper('ABCDEFG', 3, incomplete='strict') --> ABC DEF ValueError
    # grouper('ABCDEFG', 3, incomplete='ignore') --> ABC DEF
    group_args = [iter(iterable)] * n
    if incomplete == "fill":
        return zip_longest(*group_args, fillvalue=fill_value)
    if incomplete == "strict":
        return zip(*group_args, strict=True)
    if incomplete == "ignore":
        return zip(*group_args)
    else:
        raise ValueError("Expected fill, strict, or ignore")


def read_torque_data(filename, column_names=None, arm_length=TORQUE_ARM_LENGTH):
    """
    Reads a torque data file and returns a pandas dataframe. For compatibility reason, the columns are renamed
    and the force value is converted to a torque by multiplying the force by the arm_length.
    :param filename: path of the torque data file (xlsx or csv)
    :param column_names: list of column names to use instead of the ones defined in the file.
                         Default: ["Time", "Angle", "Force"]
    :param arm_length: Arm length in cm to convert force to torque
    :return: pandas dataframe
    """
    column_names = ["Time", "Angle", "Force"] if column_names is None else column_names
    # Files generated by the TorqueMeter produce incorrect values in the first column
    # That does not impact the data, since we are not using that column, but it generates Warnings from
    # openpyxl when reading the file.
    if Path(filename).suffix == ".xlsx":
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            # noinspection PyTypeChecker
            df = pd.read_excel(filename)
    elif Path(filename).suffix == ".csv":
        df = pd.read_csv(
            filename, on_bad_lines="warn"
        )
    else:
        raise ValueError(f"Cannot parse files with extension {filename}")
    #
    # There was a change between 2023 and 2024 where 
    # we switched from a 3 col format to a 4 col format
    #
    if len(df.columns)>3:
        df.drop(columns=df.columns[0], inplace=True)
    
    df.columns = column_names
    df["Torque"] = df["Force"] * arm_length
    return df


def remove_outlier_force(df, threshold=3, column="Force"):
    """
    removes from the dataframe rows where the values are further than `threshold` times the standard-deviation
    by default, a threshold of 3 sigma is used, on the `Force` column
    :param df: Dataframe
    :param threshold: values above threshold*sigma will be removed
    :param column: the column to remove outliers from
    :return: Dataframe without outliers
    """
    # noinspection PyUnresolvedReferences
    out = df[st.zscore(df[column]).abs() > threshold].index
    return df.drop(out)


def select_cycles(df, cycles_to_keep=None):
    """
    return a truncated dataframe containing only the cycles in cycles_to_keep
    :param df: the dataframe to filter
    :param cycles_to_keep: list of indices [0-N cycles] of cycles to keep. If None, keep all cycles.
    :return: a copy of the dataframe
    """
    if cycles_to_keep is None:
        return df
    temp = df.copy()
    cycles_lim = get_angle_cycles(temp["Angle"])
    for i, (s, t) in enumerate(cycles_lim):
        if i not in cycles_to_keep:
            temp.loc[s:t, "Angle"] = pd.NA
    temp.dropna(subset=["Angle", "Force"], inplace=True)
    return temp


def analyze_torque_file(filename, filter_threshold=0, cycles=None):
    """
    analyze the torque file, optionally filtering the data first, and only considering the cycles listed in `cycles`
    :param filename: the file to analyze
    :param filter_threshold: if 0 (default), no filtering. If larger than 0, then this value indicated how many times
                             the standard deviation a point needs to be considered an outlier
    :param cycles: the list of cycles [0-N cycles] to include in the analysis. If None, then all cycles are included
    :return: (slope, r) values
    """
    df = read_torque_data(filename)

    if filter_threshold > 0:
        df = remove_outlier_force(df, threshold=filter_threshold)

    cycles_lims = get_angle_cycles(df["Angle"])
    if cycles is None:
        cycles = range(0, len(cycles_lims))

    df = select_cycles(df, cycles_to_keep=cycles)
    df.dropna(subset=["Angle", "Torque"], inplace=True)
    slope, intercept, r, p, se = st.linregress(x=df["Angle"], y=df["Torque"])
    return slope, r


def parse_torque_filename(filename: str):
    m = TORQUE_DATA_FILENAME_RE.match(str(filename))
    if m is None:
        raise ValueError(f'Cannot parse filename "{filename}"')
    return m.groupdict()


def constrain(value, min_val, max_val):
    if value > max_val:
        return max_val
    elif value < min_val:
        return min_val
    else:
        return value


def parse_cycle_str(value):
    return list(map(int, value.split(",")))


class MainWindow(QMainWindow):
    def __init__(self) -> None:
        # noinspection PyArgumentList
        super(MainWindow, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        self.rabbit_info_file_path = None
        self.result_file_path = None
        self.result_df = None
        self.data_files_root_folder = None
        self.torque_file_list = []
        self.current_file = 0
        self.current_idx = 0
        self.current_analysis = None
        self.rabbit_info = None
        self.file_analyzes = []

        self.canvas = FigureCanvasQTAgg(Figure(layout="constrained"))
        self.figure = self.canvas.figure

        self.ui.rightPanelLayout.addWidget(self.canvas)
        self.ui.rightPanelLayout.setStretch(0, 0)
        self.ui.rightPanelLayout.setStretch(1, 1)

        ###
        # Signals
        ###
        self.ui.openResultFileButton.clicked.connect(
            self.open_result_file_button_clicked
        )
        self.ui.openDataFolderButton.clicked.connect(
            self.open_data_folder_button_clicked
        )
        self.ui.nextFileButton.clicked.connect(self.next_file_button_clicked)
        self.ui.prevFileButton.clicked.connect(self.prev_file_button_clicked)
        self.ui.currentFileSpinBox.valueChanged.connect(
            self.current_file_spinner_changed
        )
        self.ui.skipAlreadyAnalyzedCheckBox.clicked.connect(
            self.skip_already_analyzed_clicked
        )
        self.ui.removeOutliersCheckBox.clicked.connect(
            self.remove_outlier_checkbox_changed
        )
        self.ui.outlierThresholdSpinBox.valueChanged.connect(
            self.outlier_threshold_changed
        )
        self.ui.validateButton.clicked.connect(self.save_file)
        self.ui.cyclesToKeepEdit.textChanged.connect(self.cycles_edit_changed)
        self.ui.rejectFileButton.clicked.connect(self.reject_button_clicked)
        self.cid = self.canvas.mpl_connect("button_press_event", self.on_plot_clicked)

    def on_plot_clicked(self, event: MouseEvent):
        if event.dblclick and event.inaxes in self.figure.axes[:2]:
            logger.debug(f"MouseEvent: {event}")
            # df = read_torque_data(
            #     self.data_files_root_folder
            #     / self.result_df.loc[self.current_idx, "Filename"]
            # )
            angle_data = self.figure.axes[1].lines[0].get_ydata()
            cycle_lims = get_angle_cycles(angle_data)
            for i, (s, t) in enumerate(cycle_lims):
                if s <= event.xdata < t:
                    # click in cycle # i
                    logger.debug(f"Double click in cycle # {i}")
                    cycles_to_keep = parse_cycle_str(
                        self.result_df.loc[self.current_idx, "Cycles"]
                    )
                    if i in cycles_to_keep:
                        # remove i
                        cycles_to_keep.pop(cycles_to_keep.index(i))
                    else:
                        # add cycle i to list to keep
                        cycles_to_keep = sorted(cycles_to_keep + [i])
                    self.result_df.loc[self.current_idx, "Cycles"] = ",".join(
                        map(str, cycles_to_keep)
                    )
                    self.update_torque_analysis()
                    self.update_torque_gui()
                    break

    def open_result_file_button_clicked(self):
        self.result_file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Summary File",
            "",
            filter="Summary Files (*.xlsx)",
            options=QFileDialog.Option.DontConfirmOverwrite,
        )
        self.result_file_path = Path(self.result_file_path)
        if self.result_file_path.exists():
            self.result_df = pd.read_excel(self.result_file_path)
            logger.info(
                f"Loaded result file {self.result_file_path} with {len(self.result_df)} entries"
            )
        else:
            self.result_df = pd.DataFrame(columns=list(RESULT_FIELDS.keys())).astype(
                RESULT_FIELDS
            )
            logger.info(f"created new result file {self.result_file_path}")
        self.ui.openDataFolderButton.setEnabled(True)
        self.ui.dataFolderPathEdit.setEnabled(True)

    def open_data_folder_button_clicked(self):
        self.torque_file_list = self.get_torque_files(
            filter_already_analyzed=self.ui.skipAlreadyAnalyzedCheckBox.isChecked()
        )
        if len(self.torque_file_list) > 0:
            self.ui.currentFileSpinBox.setMaximum(len(self.torque_file_list))
            self.ui.currentFileSpinBox.setSuffix(f" / {len(self.torque_file_list)}")
            # self.ui.fileInfoGroupBox.setEnabled(True)
            self.ui.analysisGroupBox.setEnabled(True)
            self.current_file = 0
            self.process_current_file()

    def remove_outlier_checkbox_changed(self, checked):
        if checked:
            self.ui.outlierThresholdSpinBox.setEnabled(True)
            if np.isclose(self.ui.outlierThresholdSpinBox.value(), 0):
                self.ui.outlierThresholdSpinBox.setValue(DEFAULT_OUTLIER_THRESHOLD)
            self.result_df.loc[self.current_idx, "Filtered"] = (
                self.ui.outlierThresholdSpinBox.value()
            )
        else:
            self.ui.outlierThresholdSpinBox.setEnabled(False)
            self.result_df.loc[self.current_idx, "Filtered"] = 0
        self.update_torque_analysis()

    def outlier_threshold_changed(self, val):
        self.result_df.loc[self.current_idx, "Filtered"] = val
        self.update_torque_analysis()

    def cycles_edit_changed(self, text):
        self.result_df.loc[self.current_idx, "Cycles"] = text
        self.update_torque_analysis()

    def reject_button_clicked(self, checked):
        self.result_df.loc[self.current_idx, "Validated"] = checked
        self.result_df.loc[self.current_idx, "Rejected"] = checked
        self.next_file_button_clicked()

    def skip_already_analyzed_clicked(self, checked):
        self.torque_file_list = self.get_torque_files(filter_already_analyzed=checked)
        self.ui.currentFileSpinBox.setMaximum(len(self.torque_file_list))
        self.ui.currentFileSpinBox.setSuffix(f" / {len(self.torque_file_list)}")
        self.process_current_file()

    def next_file_button_clicked(self):
        self.current_file = constrain(
            self.current_file + 1, 0, len(self.torque_file_list) - 1
        )
        relative_filename = Path(self.torque_file_list[self.current_file]).relative_to(
            self.data_files_root_folder
        )
        self.current_idx = self.get_file_idx(relative_filename)
        self.ui.currentFileSpinBox.setValue(self.current_file)
        self.process_current_file()

    def prev_file_button_clicked(self):
        self.current_file = constrain(
            self.current_file - 1, 0, len(self.torque_file_list) - 1
        )
        relative_filename = Path(self.torque_file_list[self.current_file]).relative_to(
            self.data_files_root_folder
        )
        self.current_idx = self.get_file_idx(relative_filename)
        self.ui.currentFileSpinBox.setValue(self.current_file)
        self.process_current_file()

    def current_file_spinner_changed(self, val):
        self.current_file = constrain(val, 0, len(self.torque_file_list) - 1)
        self.process_current_file()

    def get_root_folder(self):
        root_folder = QFileDialog.getExistingDirectory(
            self, "Open Folder with torque files", "", QFileDialog.Option.ShowDirsOnly
        )
        return root_folder

    def get_torque_files(self, filter_already_analyzed=True):
        if self.data_files_root_folder is None:
            self.data_files_root_folder = Path(self.get_root_folder())
        file_list = sorted(
            filter(
                lambda path: path.suffix in TORQUE_FILES_EXTENSIONS,
                self.data_files_root_folder.glob("**/*"),
            )
        )

        if filter_already_analyzed and self.result_df is not None:
            # This removes the files that are already in the database,
            # but only if they have been accepted
            file_list = sorted(
            filter(
                lambda x: str(x.relative_to(self.data_files_root_folder)) 
                not in self.result_df[self.result_df["Validated"] == True]["Filename"].values,
                file_list,
            )
            )

        return list(file_list)

    def get_file_idx(self, relative_filename):
        """
        finds the index of the dataframe corresponding to the file name
        :param relative_filename: the file name (relative to root folder) to search for
        :return: the index in the dataframe (or a new index if the file is not found)
        """
        idx = self.result_df.loc[
            self.result_df["Filename"] == str(relative_filename)
        ].index
        if len(idx) == 0:
            idx = None
            logger.debug(f"file {relative_filename} not found in database")
        else:
            idx = idx.values[0]
            logger.debug(
                f"file {relative_filename} exists in database with idx [{idx}]"
            )
        return idx

    def get_next_file_idx(self):
        if self.result_df.empty:
            idx = 1
        else:
            idx = self.result_df.iloc[-1].name + 1
        while idx in self.result_df.index:
            idx += 1
        logger.debug(f"Creating new idx: [{idx}]")
        return idx

    def process_current_file(self):
        filename = self.torque_file_list[self.current_file]
        relative_filename = filename.relative_to(self.data_files_root_folder)
        logger.debug(f"Processing file [{self.current_file}][{filename}]")
        idx = self.get_file_idx(relative_filename)
        if idx is None:
            # no data in the database,
            self.current_idx = self.get_next_file_idx()
            temp = parse_torque_filename(filename.name)
            expDate = None
            for part in relative_filename.parts:
                try:
                    expDate = datetime.date.fromisoformat(part)
                    break
                except ValueError:
                    expDate = None

            self.result_df.loc[self.current_idx, "ID"] = temp["ID"]  # str
            self.result_df.loc[self.current_idx, "ExpDate"] = pd.to_datetime(expDate)
            self.result_df.loc[self.current_idx, "Age"] = int(temp["Age"])  # int
            self.result_df.loc[self.current_idx, "Limb"] = temp["Limb"]  # str
            self.result_df.loc[self.current_idx, "Side"] = temp["Side"]  # str
            # fix to handle the fact that some filename contain a unit and some don't
            m = re.match('\d+', temp['Speed'])
            if m:
                speed = float(m.group(0))
            else:
                speed = pd.NA
            self.result_df.loc[self.current_idx, "Speed"] = speed  # float
            self.result_df.loc[self.current_idx, "Comments"] = temp["Comments"]  # str
            self.result_df.loc[self.current_idx, "Filename"] = str(relative_filename)
            self.result_df.loc[self.current_idx, "Filtered"] = 0
            df = read_torque_data(filename)
            cycles = range(0, len(get_angle_cycles(df["Angle"])))
            cycles_str = ",".join(map(str, cycles))
            self.result_df.loc[self.current_idx, "Cycles"] = cycles_str
            self.result_df.loc[self.current_idx, "Rejected"] = False
        self.update_torque_analysis()
        self.update_torque_gui()

    def update_torque_analysis(self):
        """
        recomputes the slope and r values based on current filtered state and selected cycles
        :return: None
        """
        filename = (
            self.data_files_root_folder
            / self.result_df.loc[self.current_idx, "Filename"]
        )
        filter_threshold = self.result_df.loc[self.current_idx, "Filtered"]
        cycles = parse_cycle_str(self.result_df.loc[self.current_idx, "Cycles"])
        slope, r = analyze_torque_file(
            filename, filter_threshold=filter_threshold, cycles=cycles
        )
        self.result_df.loc[self.current_idx, "Slope"] = slope
        self.result_df.loc[self.current_idx, "R"] = r
        self.result_df.loc[self.current_idx, "Validated"] = False
        self.update_torque_gui()
        # self.result_df.to_excel(self.result_file_path, index=False)  # FIXME: move saving to own action
    
    def save_file(self):
        self.result_df.loc[self.current_idx, "Validated"] = True
        self.result_df.to_excel(self.result_file_path, index=False)

    def update_torque_gui(self):
        self.ui.currentFileSpinBox.setValue(int(self.current_file))
        self.ui.expDateEdit.setDate(
            QDate.fromString(
                str(self.result_df.loc[self.current_idx, "ExpDate"]),
                Qt.DateFormat.ISODate,
            )
        )
        self.ui.rabbitIDEdit.setText(str(self.result_df.loc[self.current_idx, "ID"]))
        self.ui.rabbitAgeSpinBox.setValue(
            int(self.result_df.loc[self.current_idx, "Age"])
        )
        self.ui.rabbitLimbEdit.setText(
            str(
                self.result_df.loc[self.current_idx, "Limb"]
                + self.result_df.loc[self.current_idx, "Side"]
            )
        )
        self.ui.expSpeedSpinBox.setValue(
            float(self.result_df.loc[self.current_idx, "Speed"])
        )
        self.ui.expCommentEdit.setText(
            str(self.result_df.loc[self.current_idx, "Comments"])
        )
        self.ui.removeOutliersCheckBox.setChecked(
            bool(self.result_df.loc[self.current_idx, "Filtered"] > 0)
        )
        self.ui.outlierThresholdSpinBox.setValue(
            float(self.result_df.loc[self.current_idx, "Filtered"])
        )
        self.ui.cyclesToKeepEdit.setText(
            str(self.result_df.loc[self.current_idx, "Cycles"])
        )
        self.ui.rejectFileButton.setChecked(
            bool(self.result_df.loc[self.current_idx, "Rejected"])
        )
        self.plot_torque()

    def plot_torque(self):
        df = read_torque_data(
            self.data_files_root_folder
            / self.result_df.loc[self.current_idx, "Filename"]
        )
        if self.result_df.loc[self.current_idx, "Filtered"] > 0:
            df = remove_outlier_force(
                df, threshold=self.result_df.loc[self.current_idx, "Filtered"]
            )
        cycles = parse_cycle_str(self.result_df.loc[self.current_idx, "Cycles"])
        df2 = select_cycles(df, cycles)

        self.figure.clf()
        gs = GridSpec(ncols=1, nrows=3, figure=self.figure, height_ratios=[2, 1, 8])
        ax1 = self.figure.add_subplot(gs[0])
        ax2 = self.figure.add_subplot(gs[1])
        ax3 = self.figure.add_subplot(gs[2])

        ax1.plot(df["Torque"], "-", c="C1")
        ax2.plot(df["Angle"], "-", c="C0")
        ax1.set_xlim(df.index[0], df.index[-1])
        ax2.set_xlim(df.index[0], df.index[-1])
        cycle_lims = get_angle_cycles(df["Angle"])
        for i, ((s, f), c) in enumerate(
            zip(
                cycle_lims,
                itertools.cycle(TORQUE_CYCLE_COLORS),
            )
        ):
            # noinspection PyTypeChecker
            ax1.annotate(
                f"#{i}",
                xy=(s + (f - s) / 2, 0.0),
                xycoords=("data", "axes fraction"),
                ha="center",
                va="bottom",
            )
            if i in cycles:
                ax1.axvspan(s, f, color=c)
                ax2.axvspan(s, f, color=c)
            else:
                ax1.axvspan(s, f, color=TORQUE_CYCLE_EXCLUDED)
                ax2.axvspan(s, f, color=TORQUE_CYCLE_EXCLUDED)

        ax3.plot(df2["Angle"], df2["Torque"], "o-", c=(0.8, 0.8, 0.8))
        sns.regplot(data=df2, x="Angle", y="Torque", scatter=False, ax=ax3)

        ax1.set_ylabel("Torque (g.cm)")
        ax1.set_xlabel("time (AU)")
        ax2.set_ylabel("Angle")
        ax1.xaxis.tick_top()
        ax1.xaxis.set_label_position("top")
        ax2.get_xaxis().set_visible(False)
        ax3.set_xlabel("Angle")
        ax3.set_ylabel("Torque (g.cm)")

        slope = self.result_df.loc[self.current_idx, "Slope"]
        r = self.result_df.loc[self.current_idx, "R"]
        ax3.annotate(
            f"$Stiffness={abs(slope):.3f}, r^2={r ** 2:.3f}$",
            xy=(0.5, 0),
            xycoords="axes fraction",
            xytext=(0, 5),
            textcoords="offset points",
            ha="center",
        )

        self.figure.suptitle(
            Path(self.result_df.loc[self.current_idx, "Filename"]).stem
        )
        self.figure.canvas.draw()


if __name__ == "__main__":
    # noinspection DuplicatedCode
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="increase verbosity of output (can be "
        "repeated to increase verbosity further)",
    )
    parser.add_argument(
        "--log-file",
        help="file in which the log is written. "
        "If absent or None, log is directed to stdout",
        default=None,
    )
    args = parser.parse_args()

    level = LOGGING_LEVELS[
        min(args.verbose, len(LOGGING_LEVELS) - 1)
    ]  # cap to last level index
    logger.setLevel(level=level)

    app = QApplication([])
    win = MainWindow()
    win.setWindowTitle("Torque Analyzer")
    win.show()
    app.exec()
